/* Copyright 2016 by Mariusz Bernacki. PROPRIETARY and CONFIDENTIAL content.
 * Unauthorized copying of this file, via any medium is strictly prohibited.
 * See the file "LICENSE.txt" for the full license governing this code. */
package one.chartsy.ui.chart.components;

import one.chartsy.ui.chart.SysParams;

import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;

/**
 * The base class of all autocompleter popup windows generated by the
 * application. The autocompleter is a graphical component that can display
 * list of suggestions matching the text entered by a user in the input box.
 * 
 * @author Mariusz Bernacki
 * 
 */
public abstract class AutoCompleter<T> {
    /** The logger instance. */
    protected static final Logger logger = Logger.getLogger(AutoCompleter.class.getName());
    /** The timed trigger for showing suggestion popup. */
    protected Timer delayTimer;
    /** Indicates that the {@code delayTimer} was disabled. */
    protected volatile boolean timerStopped;
    /** The list of suggestions produced. */
    protected JList<T> list = new JList<>();
    /** The popup menu with suggestions. */
    protected JPopupMenu popupMenu = new JPopupMenu();
    /** The input box. */
    protected JTextComponent component;
    /** The maximum number of suggestions visible (cached). */
    private final int visibleRowCount = SysParams.AUTOCOMPLETE_VISIBLE_ROW_COUNT.intValue();
    /** The number of click counts required to fire the accept action (cached). */
    private final int acceptClickCount = SysParams.AUTOCOMPLETE_ACCEPT_CLICK_COUNT.intValue();
    
    
    private static final String AUTOCOMPLETER = "AUTOCOMPLETER";
    
    
    /**
     * Constructs the autocompleter associated with the given text component
     * (user input box).
     * 
     * @param comp
     *            the text component
     */
    public AutoCompleter(JTextComponent comp) {
        int delay = SysParams.AUTOCOMPLETE_DELAY.intValue();
        delayTimer = new Timer(delay, (ActionEvent e) -> {
            timerStopped = false;
            try {
                showPopup();
            } catch (IOException ex) {
            }
        });
        delayTimer.setRepeats(false);
        
        component = comp;
        component.putClientProperty(AUTOCOMPLETER, this);
        JScrollPane pane = new JScrollPane(list,
                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        pane.setBorder(null);
        
        list.setFocusable(true);
        pane.getVerticalScrollBar().setFocusable(false);
        pane.getHorizontalScrollBar().setFocusable(false);
        popupMenu.add(pane);
        popupMenu.setFocusable(false);
        
        if (component instanceof JTextField) {
            component.registerKeyboardAction(showAction,
                    KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0),
                    JComponent.WHEN_FOCUSED);
            component.getDocument().addDocumentListener(documentListener);
        } else {
            component.registerKeyboardAction(showAction, KeyStroke
                    .getKeyStroke(KeyEvent.VK_SPACE, KeyEvent.CTRL_MASK),
                    JComponent.WHEN_FOCUSED);
        }
        
        component.registerKeyboardAction(upAction,
                KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0),
                JComponent.WHEN_FOCUSED);
        component.registerKeyboardAction(hidePopupAction,
                KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0),
                JComponent.WHEN_FOCUSED);
        
        popupMenu.addPopupMenuListener(new PopupMenuListener() {
            
            @Override
            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
                component.unregisterKeyboardAction(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0));
                SymbolChanger changer = getSymbolChanger();
                if (changer != null) {
                    component.registerKeyboardAction(changer.submit,
                            KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0),
                            JComponent.WHEN_FOCUSED);
                }
            }
            
            @Override
            public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
            }
            
            @Override
            public void popupMenuCanceled(PopupMenuEvent e) {
            }
        });
        list.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == acceptClickCount) {
                    ActionEvent v = new ActionEvent(component,
                            ActionEvent.ACTION_PERFORMED, "Accept");
                    acceptAction.actionPerformed(v);
                    SymbolChanger changer = getSymbolChanger();
                    if (changer != null)
                        changer.submit.actionPerformed(v);
                }
            }
        });
        list.setRequestFocusEnabled(false);
        SelectionAwareListCellRenderer.decorate(list);
    }

    public interface SelectionStateTransformable<T> {

        T getAsSelected();
    }

    private static final class SelectionAwareListCellRenderer<E> implements ListCellRenderer<E> {

        public static <E> void decorate(JList<E> list) {
            ListCellRenderer<? super E> origin = list.getCellRenderer();
            list.setCellRenderer(new SelectionAwareListCellRenderer<>(origin));
        }

        private final ListCellRenderer<E> origin;

        private SelectionAwareListCellRenderer(ListCellRenderer<E> origin) {
            this.origin = origin;
        }

        @SuppressWarnings("unchecked")
        @Override
        public Component getListCellRendererComponent(JList<? extends E> list, E value, int index, boolean isSelected, boolean cellHasFocus) {
            if (isSelected && value instanceof SelectionStateTransformable)
                value = ((SelectionStateTransformable<E>) value).getAsSelected();

            return origin.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
        }
    }

    /**
     * If the direct parent of the text {@code component} is an instance of {@link SymbolChanger}
     * returns that instance. Otherwise {@code null} is returned.
     * 
     * @return the symbol changer
     */
    protected SymbolChanger getSymbolChanger() {
        Component parent = component.getParent();
        return (parent instanceof SymbolChanger)? (SymbolChanger) parent : null;
    }
    
    public void enableTimer() {
        timerStopped = false;
    }
    
    public void disableTimer() {
        delayTimer.stop();
        timerStopped = true;
    }
    
    static Action acceptAction = new AbstractAction() {
        /** The serial version UID */
        private static final long serialVersionUID = -6492024454591122704L;
        
        @Override
        public void actionPerformed(ActionEvent e) {
            JComponent comp = (JComponent) e.getSource();
            AutoCompleter<?> completer = (AutoCompleter<?>) comp.getClientProperty(AUTOCOMPLETER);
            completer.popupMenu.setVisible(false);
            completer.disableTimer();
            completer.acceptedListItem(completer.list.getSelectedValue());
        }
    };
    
    DocumentListener documentListener = new DocumentListener() {
        @Override
        public void insertUpdate(DocumentEvent e) {
            doLaunchTimer();
        }
        
        @Override
        public void removeUpdate(DocumentEvent e) {
            doLaunchTimer();
        }
        
        private void doLaunchTimer() {
            if (!timerStopped) {
                if (delayTimer.isRunning())
                    delayTimer.restart();
                else if (!component.isFocusable() || component.isFocusOwner())
                    delayTimer.start();
            }
        }
        
        @Override
        public void changedUpdate(DocumentEvent e) {
        }
    };
    
    private void showPopup() throws IOException {
        popupMenu.setVisible(false);
        if (component.isEnabled() && updateListData() && list.getModel().getSize() != 0) {
            if (!(component instanceof JTextField))
                component.getDocument().addDocumentListener(documentListener);
            component.registerKeyboardAction(acceptAction,
                    KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0),
                    JComponent.WHEN_FOCUSED);
            int size = list.getModel().getSize();
            list.setVisibleRowCount(Math.min(size, visibleRowCount));
            list.ensureIndexIsVisible(0);
            
            int x = 0;
            try {
                int caretDot = component.getCaret().getDot();
                int caretMark = component.getCaret().getMark();
                int pos = Math.min(caretDot, caretMark);
                x = component.getUI().modelToView(component, pos).x;
            } catch (BadLocationException e) {
                logger.log(Level.SEVERE, null, e);
            }
            popupMenu.show(component, x, component.getHeight());
        }
    }
    
    static Action showAction = new AbstractAction() {
        
        private static final long serialVersionUID = -3239063033929574976L;
        
        @Override
        public void actionPerformed(ActionEvent e) {
            JComponent tf = (JComponent) e.getSource();
            AutoCompleter<?> completer = (AutoCompleter<?>) tf.getClientProperty(AUTOCOMPLETER);
            if (tf.isEnabled()) {
                if (completer.popupMenu.isVisible())
                    completer.selectNextPossibleValue();
                else {
                    try {
                        completer.showPopup();
                    } catch (IOException ex) {
                        return;
                    }
                }
            }
        }
    };
    
    static Action upAction = new AbstractAction() {
        /** Serial version UID. */
        private static final long serialVersionUID = -2319631777295762823L;
        
        @Override
        public void actionPerformed(ActionEvent e) {
            JComponent tf = (JComponent) e.getSource();
            AutoCompleter<?> completer = (AutoCompleter<?>) tf.getClientProperty(AUTOCOMPLETER);
            if (tf.isEnabled()) {
                if (completer.popupMenu.isVisible())
                    completer.selectPreviousPossibleValue();
            }
        }
    };
    
    static Action hidePopupAction = new AbstractAction() {
        /** Serial version UID. */
        private static final long serialVersionUID = 6296293698682328185L;
        
        @Override
        public void actionPerformed(ActionEvent e) {
            JComponent tf = (JComponent) e.getSource();
            AutoCompleter<?> completer = (AutoCompleter<?>) tf.getClientProperty(AUTOCOMPLETER);
            if (tf.isEnabled())
                completer.popupMenu.setVisible(false);
        }
    };
    
    /**
     * Selects the next item in the list. It won't change the selection if the
     * currently selected item is already the last item.
     */
    protected void selectNextPossibleValue() {
        int si = list.getSelectedIndex();
        if (si < list.getModel().getSize() - 1) {
            list.setSelectedIndex(si + 1);
            list.ensureIndexIsVisible(si + 1);
        }
    }
    
    /**
     * Selects the previous item in the list. It won't change the selection if
     * the currently selected item is already the first item.
     */
    protected void selectPreviousPossibleValue() {
        int si = list.getSelectedIndex();
        if (si > 0) {
            list.setSelectedIndex(si - 1);
            list.ensureIndexIsVisible(si - 1);
        }
    }
    
    // update list model depending on the data in textfield
    protected abstract boolean updateListData() throws IOException;
    
    // user has selected some item in the list. update textfield accordingly...
    protected abstract void acceptedListItem(Object selected);
    
}
